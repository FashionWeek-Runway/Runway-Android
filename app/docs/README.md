# 기능 요구 사항 ✅

## 회원가입, 로그인

로그인, 회원가입에 필요한 모든 도메인 로직체크는 `모델 객체`가 일하도록 만들었다.

### 로그인 뷰

로그인시 전화번호 및 비밀번호를 입력할 때 다음과 같은 규칙을 따라야 한다.

* 전화번호 입력 : (-제외하고 작성)
    * 숫자만 입력 -> `TextField`의 키보드 타입을 `Number`로 제한
* 비밀번호 입력 : 평상시 비밀번호 입력시 •••••a 표기. 마지막 자리만 보여주고, 나머지는 가림 표시. 비밀보기 버튼 눌렀을 경우 비밀번호 전체 공개. 버튼을 누르고 입력
  시 비밀번호 계속 보여짐
    * 비밀번호 입력시 마지막 번호가 보이는 것은 `VisualTranformation`을 커스텀한 `LastPasswordVisibleVisualTransformation`
      를 `TextField`에서 사용한다. 이는 `LastPasswordVisibleCustomTextField`컴포저블로 구현이 되어 있다.

### 회원가입 (유저 인적사항 입력)

유저 정보 예외처리 사항

* 이름 및 국적 : `NameAndNationality` -> 이름이 공백만 아니면 됨
* 성별 : `Gender` -> Unknown만 아니면 됨
* 생년월일 : `Birth` -> 숫자만 입력, 정확히 8자
* 휴대폰 번호 : `Phone` -> 번호가 정확히 11자리 여야함(하이픈 없음)

사용자는 해당 예외처리를 모두 지켜야 버튼이 enable된다.

인증 문자요쳥 버튼이 눌릴 시 3분 타이머를 `SignInViewModel`에서 돌리며 이시간내에 인증번호 검증을 수행해야한다.

### 회원가입 (인증번호 검증)

인증번호는 백스택으로 돌아와도 유지되게 진행한다.
`SignInViewModel`에 존재하는 Timer가 0초 이하가 되면 인증이 불가능해야 한다.

사용자는 6자리의 인증번호를 입력해야 버튼이 enable된다.

재요청 버튼을 누르면 타이머가 초기화(3분)되며, 유저의 전화번호로 다시 문자가 간다.

### 회원가입 (비밀번호)

`Password` 비밀번호는 숫자, 영문으로 이루어지며, 8자 이상 16자 이하여야 한다.

사용자는 비밀번호 형식을 맞춰야 버튼이 enable된다.

### 회원가입 (프로필 이미지, 닉네임)

* 닉네임 : 한글, 영어, 숫자 혼합 2~10글자이여야 하며 서버와의 중복체크를 거쳐야 한다.

정규식은 다음과 같다.

```
"""^[ㄱ-ㅎ|가-힣|a-z|A-Z|0-9|]{2,10}$"""
```

* 프로필 이미지
    * Oauth로그인은 SNS 프로필이미지를 가져오기
    * 전화번호 로그인은 갤러리나 카메라로 사진찍기 (`외부 저장소`, `카메라` 접근 권한 필요)

#### 여기서 프로필 이미지에 관하여

프로필이미지는 `ProfileImageType`를 사용해 `sealed class`로 관리하되 서버의 파라미터에 대한 분기처리를 다음과 같이 한다.

**기본로그인**

1. 아무런 이미지를 선택하지 않았을 때 (`ProfileImageType.DEFAULT`) `profileImgUrl`에는 공백("")을, `multipartFile`
   에는 `null`을 보낸다.
2. 기기내의 이미지를 선택했을 때 `Uri`로 부터 `Path`를 추출하여 `File`을 찾은 뒤 해당 파일을 서버로 보낸다. (`profileImgUrl`에는 공백("")을
   보낸다.)
3. 소셜로그인은 제공되는 `profileImgUrl`을 통해 이미지 주소를 가져오되, 유저가 따로 이미지를 설정하거나 이미지를 바꾸면 1, 2번 플로우로 동일하게 진행한다.

### 카테고리 선택

카테고리는 최소 1개, 최대는 제한이 없다.

---

## 프로젝트를 진행하며 공부한 것 및 정리할 것

1. `LastPasswordVisibleCustomTextField` 만들고 에러 메시지를 뛰우는 과정
2. `imePadding()`사용법과 키보드가 올라왔을 때 버튼을 위로 올리는 법
3. 상태 호이스팅을 활용한 `Screen`과 `Stateholder`의 관리 예제
4. `CustomBottomSheet`만드는 과정과 동작 방법 (`rememberBottomSheet`를 활용해 `Stateholder`를 만들어 재사용하는 과정)
5. 람다 식을 전달할 때의 멤버참조와 코틀린의 리플렉션에 관하여
